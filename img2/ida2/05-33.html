<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
        <script src="https://unpkg.com/three@0.137.4/examples/js/utils/BufferGeometryUtils.js"></script>
        <script src="https://unpkg.com/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
        <script src="https://unpkg.com/stats.js@0.17.0/build/stats.min.js"></script>
        <script>
            window.addEventListener('DOMContentLoaded',  init);
 function init() {
    const width = 960; 
    const height = 540;
    //const CELL_NUM = 20;
    //function init() {
        //let rot = 0; 
        //let mouseX = 0;
        //document.addEventListener("mousemove", (event) =>{
            //mouseX = event.pageX;
        //});
    const renderer = new THREE.WebGLRenderer({
     canvas: document.querySelector('#myCanvas'),
 });
 renderer.setPixelRatio(window.devicePixelRatio);
 renderer.setSize(width, height);
 const scene = new THREE.Scene();
 const camera = new THREE.PerspectiveCamera(45, width / height);
 camera.position.set(0, 0, 400);
 const CELL_NUM = 25;
 const boxes = [];
 //const container = new THREE.Group();
 //scene.add(container);
 //const material = new THREE.MeshNormalMaterial();
 for (let i = 0; i < CELL_NUM; i++){
    for (let j = 0; j < CELL_NUM; j++){
        for (let k = 0; k < CELL_NUM; k++){
            const geometryBox = new THREE.BoxGeometry(5, 5, 5);
                const geometryTranslated = geometryBox.translate(
                10 * (i - CELL_NUM / 2),
                10 * (j - CELL_NUM / 2),
                10 * (k - CELL_NUM / 2),
            );
            boxes.push(geometryTranslated);
            //const mesh = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), material);
            //mesh.position.set(10 * (i - CELL_NUM / 2), 10 * (j - CELL_NUM / 2), 10 * (k - CELL_NUM / 2));
            //container.add(mesh);
        }
    }
 }
 const controls = new THREE.OrbitControls(camera, document.body);
 const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries(boxes);
 const material = new THREE.MeshNormalMaterial();
 const mesh = new THREE.Mesh(geometry, material);
 scene.add(mesh);
 const stats = new Stats();
 stats.domElement.style.position = 'absolute';
 stats.domElement.style.top = '10px';
 document.body.appendChild(stats.domElement);
 tick();
 function tick(){
     mesh.rotation.x += Math.PI / 180;
     mesh.rotation.y += Math.PI / 180;
 //const geometry = new THREE.SphereGeometry(300, 30, 30);
 //const loader = new THREE.TextureLoader();
 //const texture = loader.load('img/earthmap1k.jpg');
 //const material = new THREE.MeshStandardMaterial({ map: texture});
 //const material = new THREE.MeshStandardMaterial({ color: 0xff0000});
 //const mesh = new THREE.Mesh(geometry, material);
 //scene.add(mesh);
 //const directionalLight = new THREE.DirectionalLight(0xffffff);
 //directionalLight.position.set(1, 1, 1);
 //scene.add(directionalLight);
 //tick();
 //function tick(){
     //mesh.rotation.y += 0.01;
     //const targetRot = (mouseX / window.innerWidth) * 360;
    // rot += (targetRot - rot) * 0.02;
     //const radian = rot * Math.PI / 180;
     //camera.position.x = 1000 * Math.sin(radian);
     //camera.position.z = 1000 * Math.cos(radian);
 renderer.render(scene, camera);
 document.getElementById('info').innerHTML = JSON.stringify(renderer.info.render, '',' ')
 stats.update();
 requestAnimationFrame(tick);
 }
}
        </script>
    </head>
    <body>
        <canvas id="myCanvas"></canvas>
        <pre id="info"></pre>
    </body>
</html>